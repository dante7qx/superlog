## Finchley 版本

### 一. Hibernate

	Springboot 2.* 使用的 Hibernate 升级到了 3.0 版本，JpaRepository 的 getOne(id) 实际的实现是 SimpleJpaRepository.getOne（id）--> SessionImpl.load(class,id)，而 load 方法是懒加载机制。即 PO 在使用时才会去执行 SQL 获取。因此如果将 getOne(id) 的结果直接返回，会报`org.hibernate.LazyInitializationException`。

**解决方法**

```java
// 方式1 - 在实体类上添加注解（测试时使用，生产环境不使用）
import org.hibernate.annotations.Proxy;
@Proxy(lazy = false)

// 方式2 - 不要返回使用DB的映射类，进行转化成 DTO 后再返回
UserRespDTO userResp = new UserRespDTO();
User user = userDao.getOne(id);
BeanUtils.copyProperties(user, userResp);
return userResp;

// 方式3 - 不使用 getOne，使用 findById 方法
userDao.findById(id).get()
```

**参考：** https://blog.csdn.net/flyskyhunter/article/details/71104429

### 二. H2 内存库

主键自增

```sql
drop table user if exists;
create table user (
	id bigint generated by default as identity,
	account varchar(32),
	primary key(id)
);
```

```java
@Id
@GeneratedValue(strategy = GenerationType.IDENTITY)
private Long id;
```

### 三. Eureka 注册认证

因为 Spring Security 5 默认开启了csrf 认证，所以 Eureka 的安全认证需要关闭 csrf。

```java
//  Enreka Server 
@EnableWebSecurity
public class WebSecurityConfig extends WebSecurityConfigurerAdapter {	
	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http.csrf().ignoringAntMatchers("/eureka/**");
		super.configure(http);
	}
}
```

### 四. WebClient 负载均衡

Spring WebFlux 中可以使用 WebClient + LoadBalancerExchangeFilterFunction 进行负载均衡。 

方式一

```java
// 配置
@Configuration
public class UserWebClientConfig {	
	@Bean
	@LoadBalanced
	public WebClient.Builder loadBalancedWebClientBuilder() {
		return WebClient.builder().baseUrl("http://micro-provider-user");
	}
}
// 使用
...
@Autowired
@LoadBalanced
private WebClient.Builder webClientBuilder;
...
```

方式二

```java
@Autowired
private LoadBalancerExchangeFilterFunction lbFunction;

return WebClient.builder()
				.baseUrl("http://micro-provider-user")
				.filter(lbFunction)
				.build()
				.get()
				.uri("/userx/".concat(id+""))
				.retrieve()
				.bodyToMono(User.class);
```

源码解读

```java
public class LoadBalancerExchangeFilterFunction implements ExchangeFilterFunction {
	private final LoadBalancerClient loadBalancerClient;

	public LoadBalancerExchangeFilterFunction(LoadBalancerClient loadBalancerClient) {
		this.loadBalancerClient = loadBalancerClient;
	}
	
    /**
    	1. 先通过 serviceId 找到实际请求的 url
    	2. 然后将请求 serviceId 的 request 进行包装，构造成一个新的 Request
    	3. 将新的 Request 传递到下一个 filter
    **/
	@Override
	public Mono<ClientResponse> filter(ClientRequest request, ExchangeFunction next) {
		URI originalUrl = request.url();
		String serviceId = originalUrl.getHost();
		Assert.state(serviceId != null, "Request URI does not contain a valid hostname: " + originalUrl);
		ServiceInstance instance = this.loadBalancerClient.choose(serviceId);
		URI uri = this.loadBalancerClient.reconstructURI(instance, originalUrl);
		ClientRequest newRequest = ClientRequest.method(request.method(), uri)
				.headers(headers -> headers.addAll(request.headers()))
				.cookies(cookies -> cookies.addAll(request.cookies()))
				.attributes(attributes -> attributes.putAll(request.attributes()))
				.body(request.body())
				.build();
		return next.exchange(newRequest);
	}
}
```

### 五. 新增 /features Endpoint

1. 引入 actuator 依赖

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
```

2. 添加配置

```yaml
management:
  endpoint:
    features:
      enabled: true
  endpoints:
    web:
      exposure:
        include:
        - info
        - health
        - features
```

### 六. [Spring Cloud Gateway](../Gateway 说明.md)

