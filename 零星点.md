# 1. Ajax 请求 PUT、DELETE方法

```    javascript  
$.ajax({  
	type: "POST",  
	url: "",  
	dataType : "json",  
	async : false,  
	data : {    
		//该参数指定后台接受方法类型,put/delete
		_method : "delete",  
	},  
	success : function(data) {  
    }  
});
    
```

# 2. SpringMvc 前台传递数组，后台接受方法

``` java
@RequestParam(value = "args[]") String[] args
```

# 3. Hibernate 命名策略

hibernate 自动将驼峰型转换成 `*_*` 型。即 UpdateBy —> update_by，下面的 issues 可以处理

```properties
spring.jpa.hibernate.naming.physical-strategy=org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl
```

- https://github.com/spring-projects/spring-boot/issues/6264

# 4. Long小记

```java
Long x1 = 34L;
Long x2 = 34L;

Long y1 = 334L;
Long y2 = 334L;

x1 == x2 ==> true
y1 == y2 ==> false
  
Long 会为数据创建一个初始大小为1个字节（大小为-128~127）的空间存放0或1的二进制的数据，但是当超过这个容量时，他会重新创建数据的容量在堆内存中new出来
```

# 5. request.getInputStream

1. Inputstream

   ​	InputStream:  read方法内部有一个，postion，标志当前流读取到的位置，每读取一次，位置就会移动一次，如果读到最后，InputStream.read方法会返回-1，标志已经读取完了，如果想再次读取，可以调用inputstream.reset方法，position就会移动到上次调用mark的位置，mark默认是0，所以就能从头再读了。

   ​	当然，能否reset是有条件的，它取决于markSupported,markSupported() 方法返回是否可以mark/reset。

   ​	**request.getInputStream**返回的值是**ServletInputStream**,查看**ServletInputStream**源码发现，没有重写reset方法，所以查看InputStream源码发现marksupported  返回false，并且reset方法，直接抛出异常。

   ```java
   public abstract class ServletInputStream extends InputStream {
       protected ServletInputStream() { }
       public int readLine(byte[] b, int off, int len) throws IOException {
           if (len <= 0) {
               return 0;
           }
           int count = 0, c;
           while ((c = read()) != -1) {
               b[off++] = (byte)c;
               count++;
               if (c == '\n' || count == len) {
               break;
               }
           }
           return count > 0 ? count : -1;
       }
       public abstract boolean isFinished();
       public abstract boolean isReady();
       public abstract void setReadListener(ReadListener readListener);
   }
   ```

- https://my.oschina.net/serge/blog/1094063
- http://www.jianshu.com/p/f7f8237861e7
- https://github.com/sergewu/demo


# 6. Dubbo 启动警告

dubbo2.5.7启动时会产生警告，因为dubbo默认使用 Log4j记录日志，替换Logback来输出日志，操作如下

```yacas
log4j:WARN No appenders could be found for logger (com.alibaba.dubbo.common.logger.LoggerFactory).
log4j:WARN Please initialize the log4j system properly.
log4j:WARN See http://logging.apache.org/log4j/1.2/faq.html#noconfig for more info.
```

1. 加入 Logback 的依赖（Springboot中默认加入了Logback依赖）

2. 在dubbo的依赖中要排除对log4j的依赖

   ```xml
   <dependency>
     <groupId>org.apache.zookeeper</groupId>
     <artifactId>zookeeper</artifactId>
     <version>${zookeeper.version}</version>
     <exclusions>
       <exclusion>
         <groupId>org.slf4j</groupId>
         <artifactId>slf4j-log4j12</artifactId>
       </exclusion>
       <exclusion>
         <groupId>log4j</groupId>
         <artifactId>log4j</artifactId>
       </exclusion>
     </exclusions>
   </dependency>
   ```


# 7. EasyUI, SpringMVC 传递日期

1. Spring如何处理前端传递的日期

   ​	SpringMVC 在接收前台的日期参数时，并不会将日期字符串（例：yyyy-MM-dd）自动进行转换，一般会抛出异常 `Cannot convert value of type [java.lang.String] to required type [java.util.Date] for property 'actionDate'`。

   ​	因此需要进行数据绑定，利用 @InitBinder 和 WebDataBinder，代码如下：

   ```java
   // 自定义一个 PropertyEditorSupport
   public class SpecialDateEditor extends PropertyEditorSupport {
   	@Override  
       public void setAsText(String text) {  
   		if(StringUtils.isEmpty(text)) {
   			setValue(null); 
   			return;
   		}
   		Date date = null; 
   		if(text.matches("^\\d{4}-\\d{1,2}-\\d{1,2} {1}\\d{1,2}:\\d{1,2}:\\d{1,2}$")) {
   			date = DateUtils.parseDateTime(text);
   		} else if(text.matches("^\\d{4}-\\d{1,2}-\\d{1,2} {1}\\d{1,2}:\\d{1,2}$")) {
   			date = DateUtils.parseDateTime(text, TimeFormat.LONG_DATE_MINU_PATTERN_LINE);
   		} else if(text.matches("^\\d{4}-\\d{1,2}-\\d{1,2}$")) {
   			date = DateUtils.parseDate(text);
   		} else if(text.matches("^\\d{4}-\\d{1,2}$")) {
   			date = DateUtils.parseDate(text + "-01");
   		}
           setValue(date);  
       } 
   }

   // 建立一个全局 Controller
   public class BaseController {
   	@InitBinder
       public void initBinder(WebDataBinder binder) {
   		binder.registerCustomEditor(Date.class, new SpecialDateEditor());  
       }
   }
   ```

2. SpringMVC 后端传递日期参数到前台，使用Jackson注解 @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss", timezone = "GMT+8")

   ```java
   @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss", timezone = "GMT+8")
   private Date startTime;
   ```

- https://segmentfault.com/a/1190000007013461
- http://blog.csdn.net/dailuwen/article/details/60322864
- https://xtuer.github.io/spring-mvc-to-date/

# 8. Springboot读取jar包中文件

`getClass().getClassLoader().getResourceAsStream("static/xxx.pdf");`



# 9. Mysql插入内容过长（Packet for query is too large）

解决办法：MySQL的一个系统参数：max_allowed_packet，其默认值为1048576(1M)，

查询：showVARIABLES like '%max_allowed_packet%';

修改此变量的值：

MySQL安装目录下的

my.ini文件中的[mysqld]段中的＂max_allowed_packet = 1M＂，(可能有些文件会没有这一行的)

格式为：

[mysqld]

max_allowed_packet = 1M （ 将1M更改为4M(如果没有这行内容，增加一行))，

保存，

重起MySQL服务。

现在可以load大于1M的文件了

# 10. 无限循环

for(;;)和while(true)都是无限循环

编译前              编译后 
 while (1)；      mov eax,1  
​                          test eax,eax 
​                          je foo+23h
​                          jmp foo+18h

   编译前           编译后 
​    for (；；)；  jmp foo+23h 　　
​    一目了然，for (；；)指令少，不占用寄存器，而且没有判断跳转，比while (1)好。 

# 11. ⼀个接⼝有2个不同的实现,@Autowired和@Resource

- @Autowired根据类型来进行自动注入，因为是类型相同的两个实现，需要配合@Qualifier才能达到目的

  ```java
  @Autowired
  @Qualifier("TestImpl1")
  TestService testService;
  ```

- @Resource根据名字来进行自动注入，@Resource("TestImpl1")

#12. Docker 删除 <none> 的 Image

```bash
docker rm $(docker images | grep none | awk '{print $3 }' | xargs)
```

# 13. expected single matching bean but found 2

https://blog.csdn.net/hengyunabc/article/details/78762121

```markdown
禁止的办法有两种：

1. 在main函数上配置exclude

@SpringBootApplication(exclude = { DataSourceAutoConfiguration.class, DataSourceTransactionManagerAutoConfiguration.class }) 

2. 在application.properties里配置：

spring.autoconfigure.exclude=org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration 
```

# 14. Jakson 属性命名策略

```yaml
---
spring:
  jackson:
    property-naming-strategy: ### 不设置，返回 Json 同 Pojo 属性的名字
      KEBAB_CASE			  ## 中横线分隔，例：msg-id 
      LOWER_CASE			  ## 小写，例：msgid
      LOWER_CAMEL_CASE		  ## 首字母小写驼峰，例：msgId
      UPPER_CAMEL_CASE		  ## 首字母大写驼峰，例：MsgId
      SNAKE_CASE			  ## 下横线分隔，例：msg_id

## 也可以使用注解 @JsonProperty(value = "msg_id")
```

